{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1493029105402},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1493029105402},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1493029105402},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1493029105402},{"_id":"themes/landscape/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1493029105402},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1493029105402},{"_id":"source/_posts/eventproxy.md","hash":"fe635600edb611248dc939a67402eff54255f380","modified":1493032890721},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1493029105402},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1493029105402},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1493029105402},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1493029105402},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1493029105402},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1493029105402},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1493029105402},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1493029105402},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1493029105402},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1493029105402},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1493029105402},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1493029105402},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1493029105402},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1493029105402},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1493029105402},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1493029105402},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1493029105402},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1493029105402},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1493029105402},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1493029105402},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1493029105402},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1493029105402},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1493029105402},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1493029105402},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1493029105402},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1493029105402},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1493029105402},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1493029105402},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1493029105402},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1493029105402},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1493029105402},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1493029105402},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1493029105406},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1493029105406},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1493029105406},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1493029105406},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1493029105406},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1493029105406},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1493029105406},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1493029105406},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1493029105406},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1493029105406},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1493029105406},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1493029105402},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1493029105402},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1493029105402},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1493029105402},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1493029105402},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1493029105402},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1493029105402},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1493029105402},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1493029105402},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1493029105402},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1493029105402},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1493029105402},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1493029105402},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1493029105402},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1493029105402},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1493029105402},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1493029105402},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1493029105402},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1493029105402},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1493029105402},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1493029105402},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1493029105406},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1493029105406},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1493029105406},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1493029105406},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1493029105406},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1493029105406},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1493029105402},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"fd7d0450516ab84c6337c7427f79f203a787ebcc","modified":1492692064284},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1493029105402},{"_id":"public/archives/index.html","hash":"fce3a5d67695cd7359029825ca8159f84ef7f0ec","modified":1493032913216},{"_id":"public/archives/2017/index.html","hash":"451593b45ced3b1cdc2bafe51b3a2af4d87cc4bc","modified":1493032913216},{"_id":"public/archives/2017/04/index.html","hash":"7f3763dc101a700a9d5791fcb55887ffb6e006bf","modified":1493032913217},{"_id":"public/tags/nodejs/index.html","hash":"fb28d9f8fb1e8c3b30cd63c58abc11cf4bbfb7ce","modified":1493032913217},{"_id":"public/2017/04/24/eventproxy/index.html","hash":"e3d848f9fa7c40d8a38bd7f9f241e30af2d00cb2","modified":1493032913217},{"_id":"public/index.html","hash":"1e4d0be0ea0c3917b6a4810144265e17d23b2b46","modified":1493032913217},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1493032913227},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1493032913227},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1493032913227},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1493032913227},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1493032913227},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1493032913228},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1493032913228},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1493032913228},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1493032913228},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1493032913228},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1493032913761},{"_id":"public/css/images/banner.jpg","hash":"fd7d0450516ab84c6337c7427f79f203a787ebcc","modified":1493032913765},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1493032913770},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1493032913770},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1493032913770},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1493032913770},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1493032913770},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1493032913770},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1493032913771},{"_id":"public/css/style.css","hash":"fffb3966bf36057a325498aba9ce3a2ea7bd79e1","modified":1493032913772},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1493032913773},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1493032913773},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1493032913774}],"Category":[],"Data":[],"Page":[],"Post":[{"layout":"post","title":"eventproxy","date":"2017-04-24T10:45:27.000Z","_content":"# 使用 eventproxy 控制并发\n\nby alsotang\n## 目标\n\n代码的入口是 `app.js`，当调用 `node app.js` 时，它会输出 CNode(https://cnodejs.org/ ) 社区首页的所有主题的标题，链接和第一条评论，以 json 的格式。\n\n输出示例：\n\n```js\n[\n  {\n    \"title\": \"【公告】发招聘帖的同学留意一下这里\",\n    \"href\": \"http://cnodejs.org/topic/541ed2d05e28155f24676a12\",\n    \"comment1\": \"呵呵呵呵\"\n  },\n  {\n    \"title\": \"发布一款 Sublime Text 下的 JavaScript 语法高亮插件\",\n    \"href\": \"http://cnodejs.org/topic/54207e2efffeb6de3d61f68f\",\n    \"comment1\": \"沙发！\"\n  }\n]\n```\n\n## 挑战\n\n以上文目标为基础，输出 `comment1` 的作者，以及他在 cnode 社区的积分值。\n\n示例：\n\n```js\n[\n  {\n    \"title\": \"【公告】发招聘帖的同学留意一下这里\",\n    \"href\": \"http://cnodejs.org/topic/541ed2d05e28155f24676a12\",\n    \"comment1\": \"呵呵呵呵\",\n    \"author1\": \"auser\",\n    \"score1\": 80\n  },\n  ...\n]\n```\n\n## 知识点\n\n1. 体会 Node.js 的 callback hell 之美\n2. 学习使用 eventproxy 这一利器控制并发\n\n## 课程内容\n\n*注意，cnodejs.org 网站有并发连接数的限制，所以当请求发送太快的时候会导致返回值为空或报错。建议一次抓取3个主题即可。文中的40只是为了方便讲解*\n\n这一章我们来到了 Node.js 最牛逼的地方——异步并发的内容了。\n\n上一课我们介绍了如何使用 superagent 和 cheerio 来取主页内容，那只需要发起一次 http get 请求就能办到。但这次，我们需要取出每个主题的第一条评论，这就要求我们对每个主题的链接发起请求，并用 cheerio 去取出其中的第一条评论。\n\nCNode 目前每一页有 40 个主题，于是我们就需要发起 1 + 40 个请求，来达到我们这一课的目标。\n\n后者的 40 个请求，我们并发地发起：），而且不会遇到多线程啊锁什么的，Node.js 的并发模型跟多线程不同，抛却那些观念。更具体一点的话，比如异步到底为何异步，Node.js 为何单线程却能并发这类走近科学的问题，我就不打算讲了。对于这方面有兴趣的同学，强烈推荐 @朴灵 的 《九浅一深Node.js》： http://book.douban.com/subject/25768396/ 。\n\n有些逼格比较高的朋友可能听说过 promise 和 generator 这类概念。不过我呢，只会讲 callback，主要原因是我个人只喜欢 callback。\n\n这次课程我们需要用到三个库：superagent cheerio eventproxy(https://github.com/JacksonTian/eventproxy )\n\n手脚架的工作各位自己来，我们一步一步来一起写出这个程序。\n\n首先 app.js 应该长这样\n\n```js\nvar eventproxy = require('eventproxy');\nvar superagent = require('superagent');\nvar cheerio = require('cheerio');\n// url 模块是 Node.js 标准库里面的\n// http://nodejs.org/api/url.html\nvar url = require('url');\n\nvar cnodeUrl = 'https://cnodejs.org/';\n\nsuperagent.get(cnodeUrl)\n  .end(function (err, res) {\n    if (err) {\n      return console.error(err);\n    }\n    var topicUrls = [];\n    var $ = cheerio.load(res.text);\n    // 获取首页所有的链接\n    $('#topic_list .topic_title').each(function (idx, element) {\n      var $element = $(element);\n      // $element.attr('href') 本来的样子是 /topic/542acd7d5d28233425538b04\n      // 我们用 url.resolve 来自动推断出完整 url，变成\n      // https://cnodejs.org/topic/542acd7d5d28233425538b04 的形式\n      // 具体请看 http://nodejs.org/api/url.html#url_url_resolve_from_to 的示例\n      var href = url.resolve(cnodeUrl, $element.attr('href'));\n      topicUrls.push(href);\n    });\n\n    console.log(topicUrls);\n  });\n```\n\n运行 `node app.js`\n\n输出如下图：\n\n![](https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson4/1.png)\n\nOK，这时候我们已经得到所有 url 的地址了，接下来，我们把这些地址都抓取一遍，就完成了，Node.js 就是这么简单。\n\n抓取之前，还是得介绍一下 eventproxy 这个库。\n\n用 js 写过异步的同学应该都知道，如果你要并发异步获取两三个地址的数据，并且要在获取到数据之后，对这些数据一起进行利用的话，常规的写法是自己维护一个计数器。\n\n先定义一个 `var count = 0`，然后每次抓取成功以后，就 `count++`。如果你是要抓取三个源的数据，由于你根本不知道这些异步操作到底谁先完成，那么每次当抓取成功的时候，就判断一下 `count === 3`。当值为真时，使用另一个函数继续完成操作。\n\n而 eventproxy 就起到了这个计数器的作用，它来帮你管理到底这些异步操作是否完成，完成之后，它会自动调用你提供的处理函数，并将抓取到的数据当参数传过来。\n\n假设我们不使用 eventproxy 也不使用计数器时，抓取三个源的写法是这样的：\n\n```js\n// 参考 jquery 的 $.get 的方法\n$.get(\"http://data1_source\", function (data1) {\n  // something\n  $.get(\"http://data2_source\", function (data2) {\n    // something\n    $.get(\"http://data3_source\", function (data3) {\n      // something\n      var html = fuck(data1, data2, data3);\n      render(html);\n    });\n  });\n});\n```\n\n上述的代码大家都写过吧。先获取 data1，获取完成之后获取 data2，然后再获取 data3，然后 fuck 它们，进行输出。\n\n但大家应该也想到了，其实这三个源的数据，是可以并行去获取的，data2 的获取并不依赖 data1 的完成，data3 同理也不依赖 data2。\n\n于是我们用计数器来写，会写成这样：\n\n```js\n(function () {\n  var count = 0;\n  var result = {};\n\n  $.get('http://data1_source', function (data) {\n    result.data1 = data;\n    count++;\n    handle();\n    });\n  $.get('http://data2_source', function (data) {\n    result.data2 = data;\n    count++;\n    handle();\n    });\n  $.get('http://data3_source', function (data) {\n    result.data3 = data;\n    count++;\n    handle();\n    });\n\n  function handle() {\n    if (count === 3) {\n      var html = fuck(result.data1, result.data2, result.data3);\n      render(html);\n    }\n  }\n})();\n```\n\n<del>丑的一逼，</del>也不算丑，主要我写代码好看。\n\n如果我们用 eventproxy，写出来是这样的：\n\n```js\nvar ep = new eventproxy();\nep.all('data1_event', 'data2_event', 'data3_event', function (data1, data2, data3) {\n  var html = fuck(data1, data2, data3);\n  render(html);\n});\n\n$.get('http://data1_source', function (data) {\n  ep.emit('data1_event', data);\n  });\n\n$.get('http://data2_source', function (data) {\n  ep.emit('data2_event', data);\n  });\n\n$.get('http://data3_source', function (data) {\n  ep.emit('data3_event', data);\n  });\n```\n\n好看多了是吧，也就是个高等计数器嘛。\n\n`ep.all('data1_event', 'data2_event', 'data3_event', function (data1, data2, data3) {});`\n\n这一句，监听了三个事件，分别是 `data1_event, data2_event, data3_event`，每次当一个源的数据抓取完成时，就通过 `ep.emit()` 来告诉 `ep` 自己，某某事件已经完成了。\n\n当三个事件未同时完成时，`ep.emit()` 调用之后不会做任何事；当三个事件都完成的时候，就会调用末尾的那个回调函数，来对它们进行统一处理。\n\neventproxy 提供了不少其他场景所需的 API，但最最常用的用法就是以上的这种，即：\n\n1. 先 `var ep = new eventproxy();` 得到一个 eventproxy 实例。\n1. 告诉它你要监听哪些事件，并给它一个回调函数。`ep.all('event1', 'event2', function (result1, result2) {})`。\n1. 在适当的时候 `ep.emit('event_name', eventData)`。\n\neventproxy 这套处理异步并发的思路，我一直觉得就像是汇编里面的 goto 语句一样，程序逻辑在代码中随处跳跃。本来代码已经执行到 100 行了，突然 80 行的那个回调函数又开始工作了。如果你异步逻辑复杂点的话，80 行的这个函数完成之后，又激活了 60 行的另外一个函数。并发和嵌套的问题虽然解决了，但老祖宗们消灭了几十年的 goto 语句又回来了。\n\n至于这套思想糟糕不糟糕，我个人倒是觉得还是不糟糕，用熟了看起来蛮清晰的。不过 js 这门渣渣语言本来就乱嘛，什么变量提升（http://www.cnblogs.com/damonlan/archive/2012/07/01/2553425.html ）啊，没有 main 函数啊，变量作用域啊，数据类型常常简单得只有数字、字符串、哈希、数组啊，这一系列的问题，都不是事儿。\n\n编程语言美丑啥的，咱心中有佛就好。\n\n回到正题，之前我们已经得到了一个长度为 40 的 `topicUrls` 数组，里面包含了每条主题的链接。那么意味着，我们接下来要发出 40 个并发请求。我们需要用到 eventproxy 的 `#after` API。\n\n大家自行学习一下这个 API 吧：https://github.com/JacksonTian/eventproxy#%E9%87%8D%E5%A4%8D%E5%BC%82%E6%AD%A5%E5%8D%8F%E4%BD%9C\n\n我代码就直接贴了哈。\n\n```js\n// 得到 topicUrls 之后\n\n// 得到一个 eventproxy 的实例\nvar ep = new eventproxy();\n\n// 命令 ep 重复监听 topicUrls.length 次（在这里也就是 40 次） `topic_html` 事件再行动\nep.after('topic_html', topicUrls.length, function (topics) {\n  // topics 是个数组，包含了 40 次 ep.emit('topic_html', pair) 中的那 40 个 pair\n\n  // 开始行动\n  topics = topics.map(function (topicPair) {\n    // 接下来都是 jquery 的用法了\n    var topicUrl = topicPair[0];\n    var topicHtml = topicPair[1];\n    var $ = cheerio.load(topicHtml);\n    return ({\n      title: $('.topic_full_title').text().trim(),\n      href: topicUrl,\n      comment1: $('.reply_content').eq(0).text().trim(),\n    });\n  });\n\n  console.log('final:');\n  console.log(topics);\n});\n\ntopicUrls.forEach(function (topicUrl) {\n  superagent.get(topicUrl)\n    .end(function (err, res) {\n      console.log('fetch ' + topicUrl + ' successful');\n      ep.emit('topic_html', [topicUrl, res.text]);\n    });\n});\n```\n\n\n\n\n\n\n\n\n\n","source":"_posts/eventproxy.md","raw":"---\nlayout: post\ntitle: eventproxy\ndate: 2017-04-24 18:45:27\ntags: nodejs\n---\n# 使用 eventproxy 控制并发\n\nby alsotang\n## 目标\n\n代码的入口是 `app.js`，当调用 `node app.js` 时，它会输出 CNode(https://cnodejs.org/ ) 社区首页的所有主题的标题，链接和第一条评论，以 json 的格式。\n\n输出示例：\n\n```js\n[\n  {\n    \"title\": \"【公告】发招聘帖的同学留意一下这里\",\n    \"href\": \"http://cnodejs.org/topic/541ed2d05e28155f24676a12\",\n    \"comment1\": \"呵呵呵呵\"\n  },\n  {\n    \"title\": \"发布一款 Sublime Text 下的 JavaScript 语法高亮插件\",\n    \"href\": \"http://cnodejs.org/topic/54207e2efffeb6de3d61f68f\",\n    \"comment1\": \"沙发！\"\n  }\n]\n```\n\n## 挑战\n\n以上文目标为基础，输出 `comment1` 的作者，以及他在 cnode 社区的积分值。\n\n示例：\n\n```js\n[\n  {\n    \"title\": \"【公告】发招聘帖的同学留意一下这里\",\n    \"href\": \"http://cnodejs.org/topic/541ed2d05e28155f24676a12\",\n    \"comment1\": \"呵呵呵呵\",\n    \"author1\": \"auser\",\n    \"score1\": 80\n  },\n  ...\n]\n```\n\n## 知识点\n\n1. 体会 Node.js 的 callback hell 之美\n2. 学习使用 eventproxy 这一利器控制并发\n\n## 课程内容\n\n*注意，cnodejs.org 网站有并发连接数的限制，所以当请求发送太快的时候会导致返回值为空或报错。建议一次抓取3个主题即可。文中的40只是为了方便讲解*\n\n这一章我们来到了 Node.js 最牛逼的地方——异步并发的内容了。\n\n上一课我们介绍了如何使用 superagent 和 cheerio 来取主页内容，那只需要发起一次 http get 请求就能办到。但这次，我们需要取出每个主题的第一条评论，这就要求我们对每个主题的链接发起请求，并用 cheerio 去取出其中的第一条评论。\n\nCNode 目前每一页有 40 个主题，于是我们就需要发起 1 + 40 个请求，来达到我们这一课的目标。\n\n后者的 40 个请求，我们并发地发起：），而且不会遇到多线程啊锁什么的，Node.js 的并发模型跟多线程不同，抛却那些观念。更具体一点的话，比如异步到底为何异步，Node.js 为何单线程却能并发这类走近科学的问题，我就不打算讲了。对于这方面有兴趣的同学，强烈推荐 @朴灵 的 《九浅一深Node.js》： http://book.douban.com/subject/25768396/ 。\n\n有些逼格比较高的朋友可能听说过 promise 和 generator 这类概念。不过我呢，只会讲 callback，主要原因是我个人只喜欢 callback。\n\n这次课程我们需要用到三个库：superagent cheerio eventproxy(https://github.com/JacksonTian/eventproxy )\n\n手脚架的工作各位自己来，我们一步一步来一起写出这个程序。\n\n首先 app.js 应该长这样\n\n```js\nvar eventproxy = require('eventproxy');\nvar superagent = require('superagent');\nvar cheerio = require('cheerio');\n// url 模块是 Node.js 标准库里面的\n// http://nodejs.org/api/url.html\nvar url = require('url');\n\nvar cnodeUrl = 'https://cnodejs.org/';\n\nsuperagent.get(cnodeUrl)\n  .end(function (err, res) {\n    if (err) {\n      return console.error(err);\n    }\n    var topicUrls = [];\n    var $ = cheerio.load(res.text);\n    // 获取首页所有的链接\n    $('#topic_list .topic_title').each(function (idx, element) {\n      var $element = $(element);\n      // $element.attr('href') 本来的样子是 /topic/542acd7d5d28233425538b04\n      // 我们用 url.resolve 来自动推断出完整 url，变成\n      // https://cnodejs.org/topic/542acd7d5d28233425538b04 的形式\n      // 具体请看 http://nodejs.org/api/url.html#url_url_resolve_from_to 的示例\n      var href = url.resolve(cnodeUrl, $element.attr('href'));\n      topicUrls.push(href);\n    });\n\n    console.log(topicUrls);\n  });\n```\n\n运行 `node app.js`\n\n输出如下图：\n\n![](https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson4/1.png)\n\nOK，这时候我们已经得到所有 url 的地址了，接下来，我们把这些地址都抓取一遍，就完成了，Node.js 就是这么简单。\n\n抓取之前，还是得介绍一下 eventproxy 这个库。\n\n用 js 写过异步的同学应该都知道，如果你要并发异步获取两三个地址的数据，并且要在获取到数据之后，对这些数据一起进行利用的话，常规的写法是自己维护一个计数器。\n\n先定义一个 `var count = 0`，然后每次抓取成功以后，就 `count++`。如果你是要抓取三个源的数据，由于你根本不知道这些异步操作到底谁先完成，那么每次当抓取成功的时候，就判断一下 `count === 3`。当值为真时，使用另一个函数继续完成操作。\n\n而 eventproxy 就起到了这个计数器的作用，它来帮你管理到底这些异步操作是否完成，完成之后，它会自动调用你提供的处理函数，并将抓取到的数据当参数传过来。\n\n假设我们不使用 eventproxy 也不使用计数器时，抓取三个源的写法是这样的：\n\n```js\n// 参考 jquery 的 $.get 的方法\n$.get(\"http://data1_source\", function (data1) {\n  // something\n  $.get(\"http://data2_source\", function (data2) {\n    // something\n    $.get(\"http://data3_source\", function (data3) {\n      // something\n      var html = fuck(data1, data2, data3);\n      render(html);\n    });\n  });\n});\n```\n\n上述的代码大家都写过吧。先获取 data1，获取完成之后获取 data2，然后再获取 data3，然后 fuck 它们，进行输出。\n\n但大家应该也想到了，其实这三个源的数据，是可以并行去获取的，data2 的获取并不依赖 data1 的完成，data3 同理也不依赖 data2。\n\n于是我们用计数器来写，会写成这样：\n\n```js\n(function () {\n  var count = 0;\n  var result = {};\n\n  $.get('http://data1_source', function (data) {\n    result.data1 = data;\n    count++;\n    handle();\n    });\n  $.get('http://data2_source', function (data) {\n    result.data2 = data;\n    count++;\n    handle();\n    });\n  $.get('http://data3_source', function (data) {\n    result.data3 = data;\n    count++;\n    handle();\n    });\n\n  function handle() {\n    if (count === 3) {\n      var html = fuck(result.data1, result.data2, result.data3);\n      render(html);\n    }\n  }\n})();\n```\n\n<del>丑的一逼，</del>也不算丑，主要我写代码好看。\n\n如果我们用 eventproxy，写出来是这样的：\n\n```js\nvar ep = new eventproxy();\nep.all('data1_event', 'data2_event', 'data3_event', function (data1, data2, data3) {\n  var html = fuck(data1, data2, data3);\n  render(html);\n});\n\n$.get('http://data1_source', function (data) {\n  ep.emit('data1_event', data);\n  });\n\n$.get('http://data2_source', function (data) {\n  ep.emit('data2_event', data);\n  });\n\n$.get('http://data3_source', function (data) {\n  ep.emit('data3_event', data);\n  });\n```\n\n好看多了是吧，也就是个高等计数器嘛。\n\n`ep.all('data1_event', 'data2_event', 'data3_event', function (data1, data2, data3) {});`\n\n这一句，监听了三个事件，分别是 `data1_event, data2_event, data3_event`，每次当一个源的数据抓取完成时，就通过 `ep.emit()` 来告诉 `ep` 自己，某某事件已经完成了。\n\n当三个事件未同时完成时，`ep.emit()` 调用之后不会做任何事；当三个事件都完成的时候，就会调用末尾的那个回调函数，来对它们进行统一处理。\n\neventproxy 提供了不少其他场景所需的 API，但最最常用的用法就是以上的这种，即：\n\n1. 先 `var ep = new eventproxy();` 得到一个 eventproxy 实例。\n1. 告诉它你要监听哪些事件，并给它一个回调函数。`ep.all('event1', 'event2', function (result1, result2) {})`。\n1. 在适当的时候 `ep.emit('event_name', eventData)`。\n\neventproxy 这套处理异步并发的思路，我一直觉得就像是汇编里面的 goto 语句一样，程序逻辑在代码中随处跳跃。本来代码已经执行到 100 行了，突然 80 行的那个回调函数又开始工作了。如果你异步逻辑复杂点的话，80 行的这个函数完成之后，又激活了 60 行的另外一个函数。并发和嵌套的问题虽然解决了，但老祖宗们消灭了几十年的 goto 语句又回来了。\n\n至于这套思想糟糕不糟糕，我个人倒是觉得还是不糟糕，用熟了看起来蛮清晰的。不过 js 这门渣渣语言本来就乱嘛，什么变量提升（http://www.cnblogs.com/damonlan/archive/2012/07/01/2553425.html ）啊，没有 main 函数啊，变量作用域啊，数据类型常常简单得只有数字、字符串、哈希、数组啊，这一系列的问题，都不是事儿。\n\n编程语言美丑啥的，咱心中有佛就好。\n\n回到正题，之前我们已经得到了一个长度为 40 的 `topicUrls` 数组，里面包含了每条主题的链接。那么意味着，我们接下来要发出 40 个并发请求。我们需要用到 eventproxy 的 `#after` API。\n\n大家自行学习一下这个 API 吧：https://github.com/JacksonTian/eventproxy#%E9%87%8D%E5%A4%8D%E5%BC%82%E6%AD%A5%E5%8D%8F%E4%BD%9C\n\n我代码就直接贴了哈。\n\n```js\n// 得到 topicUrls 之后\n\n// 得到一个 eventproxy 的实例\nvar ep = new eventproxy();\n\n// 命令 ep 重复监听 topicUrls.length 次（在这里也就是 40 次） `topic_html` 事件再行动\nep.after('topic_html', topicUrls.length, function (topics) {\n  // topics 是个数组，包含了 40 次 ep.emit('topic_html', pair) 中的那 40 个 pair\n\n  // 开始行动\n  topics = topics.map(function (topicPair) {\n    // 接下来都是 jquery 的用法了\n    var topicUrl = topicPair[0];\n    var topicHtml = topicPair[1];\n    var $ = cheerio.load(topicHtml);\n    return ({\n      title: $('.topic_full_title').text().trim(),\n      href: topicUrl,\n      comment1: $('.reply_content').eq(0).text().trim(),\n    });\n  });\n\n  console.log('final:');\n  console.log(topics);\n});\n\ntopicUrls.forEach(function (topicUrl) {\n  superagent.get(topicUrl)\n    .end(function (err, res) {\n      console.log('fetch ' + topicUrl + ' successful');\n      ep.emit('topic_html', [topicUrl, res.text]);\n    });\n});\n```\n\n\n\n\n\n\n\n\n\n","slug":"eventproxy","published":1,"updated":"2017-04-24T11:21:30.721Z","comments":1,"photos":[],"link":"","_id":"cj1w18wmp00006xwmdyiuok5w","content":"<h1 id=\"使用-eventproxy-控制并发\"><a href=\"#使用-eventproxy-控制并发\" class=\"headerlink\" title=\"使用 eventproxy 控制并发\"></a>使用 eventproxy 控制并发</h1><p>by alsotang</p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>代码的入口是 <code>app.js</code>，当调用 <code>node app.js</code> 时，它会输出 CNode(<a href=\"https://cnodejs.org/\" target=\"_blank\" rel=\"external\">https://cnodejs.org/</a> ) 社区首页的所有主题的标题，链接和第一条评论，以 json 的格式。</p>\n<p>输出示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">  &#123;</div><div class=\"line\">    <span class=\"string\">\"title\"</span>: <span class=\"string\">\"【公告】发招聘帖的同学留意一下这里\"</span>,</div><div class=\"line\">    <span class=\"string\">\"href\"</span>: <span class=\"string\">\"http://cnodejs.org/topic/541ed2d05e28155f24676a12\"</span>,</div><div class=\"line\">    <span class=\"string\">\"comment1\"</span>: <span class=\"string\">\"呵呵呵呵\"</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  &#123;</div><div class=\"line\">    <span class=\"string\">\"title\"</span>: <span class=\"string\">\"发布一款 Sublime Text 下的 JavaScript 语法高亮插件\"</span>,</div><div class=\"line\">    <span class=\"string\">\"href\"</span>: <span class=\"string\">\"http://cnodejs.org/topic/54207e2efffeb6de3d61f68f\"</span>,</div><div class=\"line\">    <span class=\"string\">\"comment1\"</span>: <span class=\"string\">\"沙发！\"</span></div><div class=\"line\">  &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<h2 id=\"挑战\"><a href=\"#挑战\" class=\"headerlink\" title=\"挑战\"></a>挑战</h2><p>以上文目标为基础，输出 <code>comment1</code> 的作者，以及他在 cnode 社区的积分值。</p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">  &#123;</div><div class=\"line\">    <span class=\"string\">\"title\"</span>: <span class=\"string\">\"【公告】发招聘帖的同学留意一下这里\"</span>,</div><div class=\"line\">    <span class=\"string\">\"href\"</span>: <span class=\"string\">\"http://cnodejs.org/topic/541ed2d05e28155f24676a12\"</span>,</div><div class=\"line\">    <span class=\"string\">\"comment1\"</span>: <span class=\"string\">\"呵呵呵呵\"</span>,</div><div class=\"line\">    <span class=\"string\">\"author1\"</span>: <span class=\"string\">\"auser\"</span>,</div><div class=\"line\">    <span class=\"string\">\"score1\"</span>: <span class=\"number\">80</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  ...</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<h2 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h2><ol>\n<li>体会 Node.js 的 callback hell 之美</li>\n<li>学习使用 eventproxy 这一利器控制并发</li>\n</ol>\n<h2 id=\"课程内容\"><a href=\"#课程内容\" class=\"headerlink\" title=\"课程内容\"></a>课程内容</h2><p><em>注意，cnodejs.org 网站有并发连接数的限制，所以当请求发送太快的时候会导致返回值为空或报错。建议一次抓取3个主题即可。文中的40只是为了方便讲解</em></p>\n<p>这一章我们来到了 Node.js 最牛逼的地方——异步并发的内容了。</p>\n<p>上一课我们介绍了如何使用 superagent 和 cheerio 来取主页内容，那只需要发起一次 http get 请求就能办到。但这次，我们需要取出每个主题的第一条评论，这就要求我们对每个主题的链接发起请求，并用 cheerio 去取出其中的第一条评论。</p>\n<p>CNode 目前每一页有 40 个主题，于是我们就需要发起 1 + 40 个请求，来达到我们这一课的目标。</p>\n<p>后者的 40 个请求，我们并发地发起：），而且不会遇到多线程啊锁什么的，Node.js 的并发模型跟多线程不同，抛却那些观念。更具体一点的话，比如异步到底为何异步，Node.js 为何单线程却能并发这类走近科学的问题，我就不打算讲了。对于这方面有兴趣的同学，强烈推荐 @朴灵 的 《九浅一深Node.js》： <a href=\"http://book.douban.com/subject/25768396/\" target=\"_blank\" rel=\"external\">http://book.douban.com/subject/25768396/</a> 。</p>\n<p>有些逼格比较高的朋友可能听说过 promise 和 generator 这类概念。不过我呢，只会讲 callback，主要原因是我个人只喜欢 callback。</p>\n<p>这次课程我们需要用到三个库：superagent cheerio eventproxy(<a href=\"https://github.com/JacksonTian/eventproxy\" target=\"_blank\" rel=\"external\">https://github.com/JacksonTian/eventproxy</a> )</p>\n<p>手脚架的工作各位自己来，我们一步一步来一起写出这个程序。</p>\n<p>首先 app.js 应该长这样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> eventproxy = <span class=\"built_in\">require</span>(<span class=\"string\">'eventproxy'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> superagent = <span class=\"built_in\">require</span>(<span class=\"string\">'superagent'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">'cheerio'</span>);</div><div class=\"line\"><span class=\"comment\">// url 模块是 Node.js 标准库里面的</span></div><div class=\"line\"><span class=\"comment\">// http://nodejs.org/api/url.html</span></div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> cnodeUrl = <span class=\"string\">'https://cnodejs.org/'</span>;</div><div class=\"line\"></div><div class=\"line\">superagent.get(cnodeUrl)</div><div class=\"line\">  .end(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, res</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.error(err);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> topicUrls = [];</div><div class=\"line\">    <span class=\"keyword\">var</span> $ = cheerio.load(res.text);</div><div class=\"line\">    <span class=\"comment\">// 获取首页所有的链接</span></div><div class=\"line\">    $(<span class=\"string\">'#topic_list .topic_title'</span>).each(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">idx, element</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> $element = $(element);</div><div class=\"line\">      <span class=\"comment\">// $element.attr('href') 本来的样子是 /topic/542acd7d5d28233425538b04</span></div><div class=\"line\">      <span class=\"comment\">// 我们用 url.resolve 来自动推断出完整 url，变成</span></div><div class=\"line\">      <span class=\"comment\">// https://cnodejs.org/topic/542acd7d5d28233425538b04 的形式</span></div><div class=\"line\">      <span class=\"comment\">// 具体请看 http://nodejs.org/api/url.html#url_url_resolve_from_to 的示例</span></div><div class=\"line\">      <span class=\"keyword\">var</span> href = url.resolve(cnodeUrl, $element.attr(<span class=\"string\">'href'</span>));</div><div class=\"line\">      topicUrls.push(href);</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(topicUrls);</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure>\n<p>运行 <code>node app.js</code></p>\n<p>输出如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson4/1.png\" alt=\"\"></p>\n<p>OK，这时候我们已经得到所有 url 的地址了，接下来，我们把这些地址都抓取一遍，就完成了，Node.js 就是这么简单。</p>\n<p>抓取之前，还是得介绍一下 eventproxy 这个库。</p>\n<p>用 js 写过异步的同学应该都知道，如果你要并发异步获取两三个地址的数据，并且要在获取到数据之后，对这些数据一起进行利用的话，常规的写法是自己维护一个计数器。</p>\n<p>先定义一个 <code>var count = 0</code>，然后每次抓取成功以后，就 <code>count++</code>。如果你是要抓取三个源的数据，由于你根本不知道这些异步操作到底谁先完成，那么每次当抓取成功的时候，就判断一下 <code>count === 3</code>。当值为真时，使用另一个函数继续完成操作。</p>\n<p>而 eventproxy 就起到了这个计数器的作用，它来帮你管理到底这些异步操作是否完成，完成之后，它会自动调用你提供的处理函数，并将抓取到的数据当参数传过来。</p>\n<p>假设我们不使用 eventproxy 也不使用计数器时，抓取三个源的写法是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 参考 jquery 的 $.get 的方法</span></div><div class=\"line\">$.get(<span class=\"string\">\"http://data1_source\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data1</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// something</span></div><div class=\"line\">  $.get(<span class=\"string\">\"http://data2_source\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data2</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// something</span></div><div class=\"line\">    $.get(<span class=\"string\">\"http://data3_source\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data3</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// something</span></div><div class=\"line\">      <span class=\"keyword\">var</span> html = fuck(data1, data2, data3);</div><div class=\"line\">      render(html);</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>上述的代码大家都写过吧。先获取 data1，获取完成之后获取 data2，然后再获取 data3，然后 fuck 它们，进行输出。</p>\n<p>但大家应该也想到了，其实这三个源的数据，是可以并行去获取的，data2 的获取并不依赖 data1 的完成，data3 同理也不依赖 data2。</p>\n<p>于是我们用计数器来写，会写成这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> result = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">  $.get(<span class=\"string\">'http://data1_source'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">    result.data1 = data;</div><div class=\"line\">    count++;</div><div class=\"line\">    handle();</div><div class=\"line\">    &#125;);</div><div class=\"line\">  $.get(<span class=\"string\">'http://data2_source'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">    result.data2 = data;</div><div class=\"line\">    count++;</div><div class=\"line\">    handle();</div><div class=\"line\">    &#125;);</div><div class=\"line\">  $.get(<span class=\"string\">'http://data3_source'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">    result.data3 = data;</div><div class=\"line\">    count++;</div><div class=\"line\">    handle();</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (count === <span class=\"number\">3</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> html = fuck(result.data1, result.data2, result.data3);</div><div class=\"line\">      render(html);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p><del>丑的一逼，</del>也不算丑，主要我写代码好看。</p>\n<p>如果我们用 eventproxy，写出来是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ep = <span class=\"keyword\">new</span> eventproxy();</div><div class=\"line\">ep.all(<span class=\"string\">'data1_event'</span>, <span class=\"string\">'data2_event'</span>, <span class=\"string\">'data3_event'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data1, data2, data3</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> html = fuck(data1, data2, data3);</div><div class=\"line\">  render(html);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">$.get(<span class=\"string\">'http://data1_source'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  ep.emit(<span class=\"string\">'data1_event'</span>, data);</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">$.get(<span class=\"string\">'http://data2_source'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  ep.emit(<span class=\"string\">'data2_event'</span>, data);</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">$.get(<span class=\"string\">'http://data3_source'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  ep.emit(<span class=\"string\">'data3_event'</span>, data);</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure>\n<p>好看多了是吧，也就是个高等计数器嘛。</p>\n<p><code>ep.all(&#39;data1_event&#39;, &#39;data2_event&#39;, &#39;data3_event&#39;, function (data1, data2, data3) {});</code></p>\n<p>这一句，监听了三个事件，分别是 <code>data1_event, data2_event, data3_event</code>，每次当一个源的数据抓取完成时，就通过 <code>ep.emit()</code> 来告诉 <code>ep</code> 自己，某某事件已经完成了。</p>\n<p>当三个事件未同时完成时，<code>ep.emit()</code> 调用之后不会做任何事；当三个事件都完成的时候，就会调用末尾的那个回调函数，来对它们进行统一处理。</p>\n<p>eventproxy 提供了不少其他场景所需的 API，但最最常用的用法就是以上的这种，即：</p>\n<ol>\n<li>先 <code>var ep = new eventproxy();</code> 得到一个 eventproxy 实例。</li>\n<li>告诉它你要监听哪些事件，并给它一个回调函数。<code>ep.all(&#39;event1&#39;, &#39;event2&#39;, function (result1, result2) {})</code>。</li>\n<li>在适当的时候 <code>ep.emit(&#39;event_name&#39;, eventData)</code>。</li>\n</ol>\n<p>eventproxy 这套处理异步并发的思路，我一直觉得就像是汇编里面的 goto 语句一样，程序逻辑在代码中随处跳跃。本来代码已经执行到 100 行了，突然 80 行的那个回调函数又开始工作了。如果你异步逻辑复杂点的话，80 行的这个函数完成之后，又激活了 60 行的另外一个函数。并发和嵌套的问题虽然解决了，但老祖宗们消灭了几十年的 goto 语句又回来了。</p>\n<p>至于这套思想糟糕不糟糕，我个人倒是觉得还是不糟糕，用熟了看起来蛮清晰的。不过 js 这门渣渣语言本来就乱嘛，什么变量提升（<a href=\"http://www.cnblogs.com/damonlan/archive/2012/07/01/2553425.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/damonlan/archive/2012/07/01/2553425.html</a> ）啊，没有 main 函数啊，变量作用域啊，数据类型常常简单得只有数字、字符串、哈希、数组啊，这一系列的问题，都不是事儿。</p>\n<p>编程语言美丑啥的，咱心中有佛就好。</p>\n<p>回到正题，之前我们已经得到了一个长度为 40 的 <code>topicUrls</code> 数组，里面包含了每条主题的链接。那么意味着，我们接下来要发出 40 个并发请求。我们需要用到 eventproxy 的 <code>#after</code> API。</p>\n<p>大家自行学习一下这个 API 吧：<a href=\"https://github.com/JacksonTian/eventproxy#%E9%87%8D%E5%A4%8D%E5%BC%82%E6%AD%A5%E5%8D%8F%E4%BD%9C\" target=\"_blank\" rel=\"external\">https://github.com/JacksonTian/eventproxy#%E9%87%8D%E5%A4%8D%E5%BC%82%E6%AD%A5%E5%8D%8F%E4%BD%9C</a></p>\n<p>我代码就直接贴了哈。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 得到 topicUrls 之后</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 得到一个 eventproxy 的实例</span></div><div class=\"line\"><span class=\"keyword\">var</span> ep = <span class=\"keyword\">new</span> eventproxy();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 命令 ep 重复监听 topicUrls.length 次（在这里也就是 40 次） `topic_html` 事件再行动</span></div><div class=\"line\">ep.after(<span class=\"string\">'topic_html'</span>, topicUrls.length, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">topics</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// topics 是个数组，包含了 40 次 ep.emit('topic_html', pair) 中的那 40 个 pair</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 开始行动</span></div><div class=\"line\">  topics = topics.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">topicPair</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 接下来都是 jquery 的用法了</span></div><div class=\"line\">    <span class=\"keyword\">var</span> topicUrl = topicPair[<span class=\"number\">0</span>];</div><div class=\"line\">    <span class=\"keyword\">var</span> topicHtml = topicPair[<span class=\"number\">1</span>];</div><div class=\"line\">    <span class=\"keyword\">var</span> $ = cheerio.load(topicHtml);</div><div class=\"line\">    <span class=\"keyword\">return</span> (&#123;</div><div class=\"line\">      <span class=\"attr\">title</span>: $(<span class=\"string\">'.topic_full_title'</span>).text().trim(),</div><div class=\"line\">      <span class=\"attr\">href</span>: topicUrl,</div><div class=\"line\">      <span class=\"attr\">comment1</span>: $(<span class=\"string\">'.reply_content'</span>).eq(<span class=\"number\">0</span>).text().trim(),</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'final:'</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(topics);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">topicUrls.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">topicUrl</span>) </span>&#123;</div><div class=\"line\">  superagent.get(topicUrl)</div><div class=\"line\">    .end(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, res</span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'fetch '</span> + topicUrl + <span class=\"string\">' successful'</span>);</div><div class=\"line\">      ep.emit(<span class=\"string\">'topic_html'</span>, [topicUrl, res.text]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用-eventproxy-控制并发\"><a href=\"#使用-eventproxy-控制并发\" class=\"headerlink\" title=\"使用 eventproxy 控制并发\"></a>使用 eventproxy 控制并发</h1><p>by alsotang</p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>代码的入口是 <code>app.js</code>，当调用 <code>node app.js</code> 时，它会输出 CNode(<a href=\"https://cnodejs.org/\">https://cnodejs.org/</a> ) 社区首页的所有主题的标题，链接和第一条评论，以 json 的格式。</p>\n<p>输出示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">  &#123;</div><div class=\"line\">    <span class=\"string\">\"title\"</span>: <span class=\"string\">\"【公告】发招聘帖的同学留意一下这里\"</span>,</div><div class=\"line\">    <span class=\"string\">\"href\"</span>: <span class=\"string\">\"http://cnodejs.org/topic/541ed2d05e28155f24676a12\"</span>,</div><div class=\"line\">    <span class=\"string\">\"comment1\"</span>: <span class=\"string\">\"呵呵呵呵\"</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  &#123;</div><div class=\"line\">    <span class=\"string\">\"title\"</span>: <span class=\"string\">\"发布一款 Sublime Text 下的 JavaScript 语法高亮插件\"</span>,</div><div class=\"line\">    <span class=\"string\">\"href\"</span>: <span class=\"string\">\"http://cnodejs.org/topic/54207e2efffeb6de3d61f68f\"</span>,</div><div class=\"line\">    <span class=\"string\">\"comment1\"</span>: <span class=\"string\">\"沙发！\"</span></div><div class=\"line\">  &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<h2 id=\"挑战\"><a href=\"#挑战\" class=\"headerlink\" title=\"挑战\"></a>挑战</h2><p>以上文目标为基础，输出 <code>comment1</code> 的作者，以及他在 cnode 社区的积分值。</p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">  &#123;</div><div class=\"line\">    <span class=\"string\">\"title\"</span>: <span class=\"string\">\"【公告】发招聘帖的同学留意一下这里\"</span>,</div><div class=\"line\">    <span class=\"string\">\"href\"</span>: <span class=\"string\">\"http://cnodejs.org/topic/541ed2d05e28155f24676a12\"</span>,</div><div class=\"line\">    <span class=\"string\">\"comment1\"</span>: <span class=\"string\">\"呵呵呵呵\"</span>,</div><div class=\"line\">    <span class=\"string\">\"author1\"</span>: <span class=\"string\">\"auser\"</span>,</div><div class=\"line\">    <span class=\"string\">\"score1\"</span>: <span class=\"number\">80</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  ...</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<h2 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h2><ol>\n<li>体会 Node.js 的 callback hell 之美</li>\n<li>学习使用 eventproxy 这一利器控制并发</li>\n</ol>\n<h2 id=\"课程内容\"><a href=\"#课程内容\" class=\"headerlink\" title=\"课程内容\"></a>课程内容</h2><p><em>注意，cnodejs.org 网站有并发连接数的限制，所以当请求发送太快的时候会导致返回值为空或报错。建议一次抓取3个主题即可。文中的40只是为了方便讲解</em></p>\n<p>这一章我们来到了 Node.js 最牛逼的地方——异步并发的内容了。</p>\n<p>上一课我们介绍了如何使用 superagent 和 cheerio 来取主页内容，那只需要发起一次 http get 请求就能办到。但这次，我们需要取出每个主题的第一条评论，这就要求我们对每个主题的链接发起请求，并用 cheerio 去取出其中的第一条评论。</p>\n<p>CNode 目前每一页有 40 个主题，于是我们就需要发起 1 + 40 个请求，来达到我们这一课的目标。</p>\n<p>后者的 40 个请求，我们并发地发起：），而且不会遇到多线程啊锁什么的，Node.js 的并发模型跟多线程不同，抛却那些观念。更具体一点的话，比如异步到底为何异步，Node.js 为何单线程却能并发这类走近科学的问题，我就不打算讲了。对于这方面有兴趣的同学，强烈推荐 @朴灵 的 《九浅一深Node.js》： <a href=\"http://book.douban.com/subject/25768396/\">http://book.douban.com/subject/25768396/</a> 。</p>\n<p>有些逼格比较高的朋友可能听说过 promise 和 generator 这类概念。不过我呢，只会讲 callback，主要原因是我个人只喜欢 callback。</p>\n<p>这次课程我们需要用到三个库：superagent cheerio eventproxy(<a href=\"https://github.com/JacksonTian/eventproxy\">https://github.com/JacksonTian/eventproxy</a> )</p>\n<p>手脚架的工作各位自己来，我们一步一步来一起写出这个程序。</p>\n<p>首先 app.js 应该长这样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> eventproxy = <span class=\"built_in\">require</span>(<span class=\"string\">'eventproxy'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> superagent = <span class=\"built_in\">require</span>(<span class=\"string\">'superagent'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">'cheerio'</span>);</div><div class=\"line\"><span class=\"comment\">// url 模块是 Node.js 标准库里面的</span></div><div class=\"line\"><span class=\"comment\">// http://nodejs.org/api/url.html</span></div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> cnodeUrl = <span class=\"string\">'https://cnodejs.org/'</span>;</div><div class=\"line\"></div><div class=\"line\">superagent.get(cnodeUrl)</div><div class=\"line\">  .end(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, res</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.error(err);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> topicUrls = [];</div><div class=\"line\">    <span class=\"keyword\">var</span> $ = cheerio.load(res.text);</div><div class=\"line\">    <span class=\"comment\">// 获取首页所有的链接</span></div><div class=\"line\">    $(<span class=\"string\">'#topic_list .topic_title'</span>).each(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">idx, element</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> $element = $(element);</div><div class=\"line\">      <span class=\"comment\">// $element.attr('href') 本来的样子是 /topic/542acd7d5d28233425538b04</span></div><div class=\"line\">      <span class=\"comment\">// 我们用 url.resolve 来自动推断出完整 url，变成</span></div><div class=\"line\">      <span class=\"comment\">// https://cnodejs.org/topic/542acd7d5d28233425538b04 的形式</span></div><div class=\"line\">      <span class=\"comment\">// 具体请看 http://nodejs.org/api/url.html#url_url_resolve_from_to 的示例</span></div><div class=\"line\">      <span class=\"keyword\">var</span> href = url.resolve(cnodeUrl, $element.attr(<span class=\"string\">'href'</span>));</div><div class=\"line\">      topicUrls.push(href);</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(topicUrls);</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure>\n<p>运行 <code>node app.js</code></p>\n<p>输出如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson4/1.png\" alt=\"\"></p>\n<p>OK，这时候我们已经得到所有 url 的地址了，接下来，我们把这些地址都抓取一遍，就完成了，Node.js 就是这么简单。</p>\n<p>抓取之前，还是得介绍一下 eventproxy 这个库。</p>\n<p>用 js 写过异步的同学应该都知道，如果你要并发异步获取两三个地址的数据，并且要在获取到数据之后，对这些数据一起进行利用的话，常规的写法是自己维护一个计数器。</p>\n<p>先定义一个 <code>var count = 0</code>，然后每次抓取成功以后，就 <code>count++</code>。如果你是要抓取三个源的数据，由于你根本不知道这些异步操作到底谁先完成，那么每次当抓取成功的时候，就判断一下 <code>count === 3</code>。当值为真时，使用另一个函数继续完成操作。</p>\n<p>而 eventproxy 就起到了这个计数器的作用，它来帮你管理到底这些异步操作是否完成，完成之后，它会自动调用你提供的处理函数，并将抓取到的数据当参数传过来。</p>\n<p>假设我们不使用 eventproxy 也不使用计数器时，抓取三个源的写法是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 参考 jquery 的 $.get 的方法</span></div><div class=\"line\">$.get(<span class=\"string\">\"http://data1_source\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data1</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// something</span></div><div class=\"line\">  $.get(<span class=\"string\">\"http://data2_source\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data2</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// something</span></div><div class=\"line\">    $.get(<span class=\"string\">\"http://data3_source\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data3</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// something</span></div><div class=\"line\">      <span class=\"keyword\">var</span> html = fuck(data1, data2, data3);</div><div class=\"line\">      render(html);</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>上述的代码大家都写过吧。先获取 data1，获取完成之后获取 data2，然后再获取 data3，然后 fuck 它们，进行输出。</p>\n<p>但大家应该也想到了，其实这三个源的数据，是可以并行去获取的，data2 的获取并不依赖 data1 的完成，data3 同理也不依赖 data2。</p>\n<p>于是我们用计数器来写，会写成这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> result = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">  $.get(<span class=\"string\">'http://data1_source'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">    result.data1 = data;</div><div class=\"line\">    count++;</div><div class=\"line\">    handle();</div><div class=\"line\">    &#125;);</div><div class=\"line\">  $.get(<span class=\"string\">'http://data2_source'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">    result.data2 = data;</div><div class=\"line\">    count++;</div><div class=\"line\">    handle();</div><div class=\"line\">    &#125;);</div><div class=\"line\">  $.get(<span class=\"string\">'http://data3_source'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">    result.data3 = data;</div><div class=\"line\">    count++;</div><div class=\"line\">    handle();</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (count === <span class=\"number\">3</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> html = fuck(result.data1, result.data2, result.data3);</div><div class=\"line\">      render(html);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p><del>丑的一逼，</del>也不算丑，主要我写代码好看。</p>\n<p>如果我们用 eventproxy，写出来是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ep = <span class=\"keyword\">new</span> eventproxy();</div><div class=\"line\">ep.all(<span class=\"string\">'data1_event'</span>, <span class=\"string\">'data2_event'</span>, <span class=\"string\">'data3_event'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data1, data2, data3</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> html = fuck(data1, data2, data3);</div><div class=\"line\">  render(html);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">$.get(<span class=\"string\">'http://data1_source'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  ep.emit(<span class=\"string\">'data1_event'</span>, data);</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">$.get(<span class=\"string\">'http://data2_source'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  ep.emit(<span class=\"string\">'data2_event'</span>, data);</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">$.get(<span class=\"string\">'http://data3_source'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  ep.emit(<span class=\"string\">'data3_event'</span>, data);</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure>\n<p>好看多了是吧，也就是个高等计数器嘛。</p>\n<p><code>ep.all(&#39;data1_event&#39;, &#39;data2_event&#39;, &#39;data3_event&#39;, function (data1, data2, data3) {});</code></p>\n<p>这一句，监听了三个事件，分别是 <code>data1_event, data2_event, data3_event</code>，每次当一个源的数据抓取完成时，就通过 <code>ep.emit()</code> 来告诉 <code>ep</code> 自己，某某事件已经完成了。</p>\n<p>当三个事件未同时完成时，<code>ep.emit()</code> 调用之后不会做任何事；当三个事件都完成的时候，就会调用末尾的那个回调函数，来对它们进行统一处理。</p>\n<p>eventproxy 提供了不少其他场景所需的 API，但最最常用的用法就是以上的这种，即：</p>\n<ol>\n<li>先 <code>var ep = new eventproxy();</code> 得到一个 eventproxy 实例。</li>\n<li>告诉它你要监听哪些事件，并给它一个回调函数。<code>ep.all(&#39;event1&#39;, &#39;event2&#39;, function (result1, result2) {})</code>。</li>\n<li>在适当的时候 <code>ep.emit(&#39;event_name&#39;, eventData)</code>。</li>\n</ol>\n<p>eventproxy 这套处理异步并发的思路，我一直觉得就像是汇编里面的 goto 语句一样，程序逻辑在代码中随处跳跃。本来代码已经执行到 100 行了，突然 80 行的那个回调函数又开始工作了。如果你异步逻辑复杂点的话，80 行的这个函数完成之后，又激活了 60 行的另外一个函数。并发和嵌套的问题虽然解决了，但老祖宗们消灭了几十年的 goto 语句又回来了。</p>\n<p>至于这套思想糟糕不糟糕，我个人倒是觉得还是不糟糕，用熟了看起来蛮清晰的。不过 js 这门渣渣语言本来就乱嘛，什么变量提升（<a href=\"http://www.cnblogs.com/damonlan/archive/2012/07/01/2553425.html\">http://www.cnblogs.com/damonlan/archive/2012/07/01/2553425.html</a> ）啊，没有 main 函数啊，变量作用域啊，数据类型常常简单得只有数字、字符串、哈希、数组啊，这一系列的问题，都不是事儿。</p>\n<p>编程语言美丑啥的，咱心中有佛就好。</p>\n<p>回到正题，之前我们已经得到了一个长度为 40 的 <code>topicUrls</code> 数组，里面包含了每条主题的链接。那么意味着，我们接下来要发出 40 个并发请求。我们需要用到 eventproxy 的 <code>#after</code> API。</p>\n<p>大家自行学习一下这个 API 吧：<a href=\"https://github.com/JacksonTian/eventproxy#%E9%87%8D%E5%A4%8D%E5%BC%82%E6%AD%A5%E5%8D%8F%E4%BD%9C\">https://github.com/JacksonTian/eventproxy#%E9%87%8D%E5%A4%8D%E5%BC%82%E6%AD%A5%E5%8D%8F%E4%BD%9C</a></p>\n<p>我代码就直接贴了哈。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 得到 topicUrls 之后</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 得到一个 eventproxy 的实例</span></div><div class=\"line\"><span class=\"keyword\">var</span> ep = <span class=\"keyword\">new</span> eventproxy();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 命令 ep 重复监听 topicUrls.length 次（在这里也就是 40 次） `topic_html` 事件再行动</span></div><div class=\"line\">ep.after(<span class=\"string\">'topic_html'</span>, topicUrls.length, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">topics</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// topics 是个数组，包含了 40 次 ep.emit('topic_html', pair) 中的那 40 个 pair</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 开始行动</span></div><div class=\"line\">  topics = topics.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">topicPair</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 接下来都是 jquery 的用法了</span></div><div class=\"line\">    <span class=\"keyword\">var</span> topicUrl = topicPair[<span class=\"number\">0</span>];</div><div class=\"line\">    <span class=\"keyword\">var</span> topicHtml = topicPair[<span class=\"number\">1</span>];</div><div class=\"line\">    <span class=\"keyword\">var</span> $ = cheerio.load(topicHtml);</div><div class=\"line\">    <span class=\"keyword\">return</span> (&#123;</div><div class=\"line\">      <span class=\"attr\">title</span>: $(<span class=\"string\">'.topic_full_title'</span>).text().trim(),</div><div class=\"line\">      <span class=\"attr\">href</span>: topicUrl,</div><div class=\"line\">      <span class=\"attr\">comment1</span>: $(<span class=\"string\">'.reply_content'</span>).eq(<span class=\"number\">0</span>).text().trim(),</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'final:'</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(topics);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">topicUrls.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">topicUrl</span>) </span>&#123;</div><div class=\"line\">  superagent.get(topicUrl)</div><div class=\"line\">    .end(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, res</span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'fetch '</span> + topicUrl + <span class=\"string\">' successful'</span>);</div><div class=\"line\">      ep.emit(<span class=\"string\">'topic_html'</span>, [topicUrl, res.text]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj1w18wmp00006xwmdyiuok5w","tag_id":"cj1w18wmw00016xwmgubo9ann","_id":"cj1w18wmz00026xwm1may0h41"}],"Tag":[{"name":"nodejs","_id":"cj1w18wmw00016xwmgubo9ann"}]}}